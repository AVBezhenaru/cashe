12. Кэш
Кэш -- это такая эвристическая (эмпирическая) структура данных, которая используется для оптимизации систем, где происходит выборка множества повторяющихся записей. Причём одни записи выбираются чаще, а другие реже, но заранее мы даже примерно не представляем, какие именно.

Кэш -- это своеобразная хэш-таблица, используемая в схемах, когда количество элементов в ней на большие порядки меньше, чем общее количество значений. Например, мы хотим уместить в табличку размером 1000 элементов хэш на миллионы ключей. В таких ситуациях хэш-таблица обычно быстро полностью заполняется, поэтому требуются механизмы удаления наименее "ценного" элемента.

Типичный пример -- это кэширование прокси-серверами веб-страничек, когда частота обращений к популярному адресу (ключу) столь высока, что значение ключа удобно поместить в хэш-таблицу, которая существует в оперативной памяти, и очень быстро выдавать результат. Активно используется концепция кэша в процессорах, когда доступ к оперативной памяти -- к наиболее "популярным" адресам, кэшируется в небольшом, но очень быстром буфере.

Основное отличие кэшей от других структур данных, основанных на хэш-таблицах, в том, что для кэша надо реализовать схему вытеснения некоторого элемента, когда она вся заполнена. Классическая модель хэш-таблицы будет выдавать отказ в обслуживании, а нам требуется создать на её основе новый класс, который в случае отсутствия свободных слотов будет освобождать один из слотов.

Схем такого вытеснения существует довольно много. Самые простые и популярные -- это вытеснение самого старого элемента, или вытеснение элемента, к которому зафиксировано наименьшее количество обращений. Надо отметить, что существуют немного парадоксальные схемы, когда вытесняется элемент, к которому было самое последнее обращение. Это возможно в случаях, когда максимальное количество обращений фиксируется к самым старым элементам.

Реализуйте на основе словаря новый класс NativeCache, который дополнительно будет учитывать количество обращений к каждому ключу. Когда хэш-таблица заполняется и найти свободное место не удаётся, вытесняйте элемент с наименьшим количеством обращений. Для этого в дополнение к self.values и self.slots заведите массив self.hits, который будет хранить соответствующие количества обращений.

class NativeCache:
    def __init__(self, sz):
        self.size = sz
        self.slots = [None] * self.size
        self.values = [None] * self.size
        self.hits = [0] * self.size
Смоделируйте в тестах программно ситуацию, когда хэш-таблица заполнена (например, организуйте множество коллизий) и проверьте, правильно ли работает схема вытеснения. Также проверяйте в тестах, корректно ли учитывается количество обращений к ключам.

Оценка за элегантность решения: до +700 золотых.

Это последнее занятие первого курса по алгоритмам. Напишите пожалуйста отзыв, ваши впечатления, чему вы научились, что было полезного.

Мы изучили базовые, фундаментальные структуры данных, используемые во всех современных языках программирования, и основные методы работы с ними. Главное, что теперь мы представляем, как эти структуры данных устроены изнутри, и можем успешно выбирать подходящие стандартные типы данных под конкретную задачу, а при необходимости и самостоятельно реализовывать эффективные модели хранения и обработки информации с учётом проектной специфики. Этот навык на самом деле очень ценен, так как объёмы обрабатываемых данных в серьёзных проектах постоянно растут, и правильный выбор подходящего способа работы с ними может дать выигрыш производительности в десятки, а то и сотни раз.

На втором курсе по алгоритмам мы изучаем более сложные структуры -- в частности, деревья, включая двоичные, кучи и графы. Пользоваться этим всем с хорошим пониманием внутреннего устройства умеют, наверное, единичные проценты программистов с хорошим образованием, а остальные просто придумывают кривые костыли, не подозревая о наличии готовых мощных решений.

Эти типы данных применяются сегодня практически в каждой нагрузочной системе, так как деревья дают наилучшую эффективность при поиске информации, и по этой причине огромное количество прикладных систем (например, файловые) основаны на деревьях. Графы -- это ещё более мощная абстракция, которая позволяет качественно описать весьма и весьма сложные концепции, в частности, сети -- от электрических и энергетических до военных и транспортных.
Кучи (варианты деревьев) также применяются для быстрого нахождения максимального и минимального элементов и задействованы в системах с приоритетной обработкой.

Пожалуй, самое главное, что вы продолжите на практике постепенное изучение плавно усложняющихся типов данных и алгоритмов, повышая своё мастерство программирования. Это главный подход в обучении профессиональных программистов, принятый в качестве стандарта практически во всех ведущих университетах мира, а разрабатывается он старейшей международной Ассоциацией вычислительной техники ACM.